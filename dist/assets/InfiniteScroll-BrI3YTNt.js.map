{"version":3,"file":"InfiniteScroll-BrI3YTNt.js","sources":["../../src/lessons/07-machine-coding/InfiniteScroll.tsx?raw","../../src/lessons/07-machine-coding/InfiniteScroll.tsx"],"sourcesContent":["export default \"import React, { useState, useEffect, useRef } from 'react'\\n// @ts-ignore\\nimport sourceCode from './InfiniteScroll.tsx?raw'\\n\\n// --- Mock API ---\\nconst PAGE_SIZE = 20\\nconst TOTAL_ITEMS = 100 // Limit to demonstrate \\\"End of list\\\" state\\n\\nfunction fetchItems(page: number): Promise<string[]> {\\n    return new Promise((resolve) => {\\n        setTimeout(() => {\\n            const start = (page - 1) * PAGE_SIZE\\n            // Generate mock items\\n            const newItems = Array.from({ length: PAGE_SIZE }, (_, i) => {\\n                const index = start + i + 1\\n                return `Item #${index}: ${Math.random().toString(36).substring(7)}`\\n            })\\n\\n            // Simulate end of data\\n            if (start >= TOTAL_ITEMS) {\\n                resolve([])\\n            } else {\\n                resolve(newItems)\\n            }\\n        }, 1000) // 1s delay\\n    })\\n}\\n\\n// --- Component ---\\n\\nexport default function InfiniteScroll() {\\n    const [items, setItems] = useState<string[]>([])\\n    const [page, setPage] = useState(1)\\n    const [loading, setLoading] = useState(false)\\n    const [hasMore, setHasMore] = useState(true)\\n    const [activeTab, setActiveTab] = useState<'demo' | 'code'>('demo')\\n\\n    // The \\\"Sentinel\\\" ref - the element we observe\\n    const observerTarget = useRef<HTMLDivElement>(null)\\n\\n    useEffect(() => {\\n        const observer = new IntersectionObserver(\\n            (entries) => {\\n                if (entries[0].isIntersecting && hasMore && !loading) {\\n                    setPage(prev => prev + 1)\\n                }\\n            },\\n            { threshold: 1.0 }\\n        )\\n\\n        if (observerTarget.current) {\\n            observer.observe(observerTarget.current)\\n        }\\n\\n        return () => observer.disconnect()\\n    }, [hasMore, loading])\\n\\n    // Fetch data when page changes\\n    useEffect(() => {\\n        setLoading(true)\\n        fetchItems(page).then(newItems => {\\n            if (newItems.length === 0) {\\n                setHasMore(false)\\n            } else {\\n                setItems(prev => [...prev, ...newItems])\\n            }\\n            setLoading(false)\\n        })\\n    }, [page])\\n\\n    return (\\n        <div>\\n            <h1>Infinite Scroll</h1>\\n            <p>\\n                Loads more data automatically when you scroll to the bottom using\\n                <code>IntersectionObserver</code>.\\n            </p>\\n\\n            <div style={{ marginBottom: 20, borderBottom: '1px solid var(--border-color)' }}>\\n                <button onClick={() => setActiveTab('demo')} style={getTabStyle(activeTab === 'demo')}>Implementation</button>\\n                <button onClick={() => setActiveTab('code')} style={getTabStyle(activeTab === 'code')}>Source Code</button>\\n            </div>\\n\\n            {activeTab === 'demo' ? (\\n                <>\\n                    <div style={{\\n                        height: 400,\\n                        overflowY: 'auto',\\n                        border: '1px solid var(--border-color)',\\n                        borderRadius: 8,\\n                        background: 'var(--bg-secondary)',\\n                        position: 'relative'\\n                    }}>\\n                        {items.map((item, index) => (\\n                            <div\\n                                key={index}\\n                                style={{\\n                                    padding: '20px',\\n                                    borderBottom: '1px solid var(--border-color)',\\n                                    background: 'var(--bg-primary)'\\n                                }}\\n                            >\\n                                {item}\\n                            </div>\\n                        ))}\\n\\n                        {/* Sentinel Element */}\\n                        <div ref={observerTarget} style={{ height: 20, margin: 10, textAlign: 'center', color: '#888' }}>\\n                            {loading && <span>Loading more...</span>}\\n                            {!hasMore && <span>You have reached the end!</span>}\\n                        </div>\\n                    </div>\\n\\n                    <div style={{ marginTop: 40, padding: 20, background: 'var(--bg-tertiary)', borderRadius: 8 }}>\\n                        <h3>Under the Hood: IntersectionObserver</h3>\\n                        <p>\\n                            We place a hidden (or visible loading) element at the bottom of the list.\\n                            When the browser detects it's visible, we increment the page number.\\n                        </p>\\n                        <pre style={{ margin: 0 }}>{`const observer = new IntersectionObserver((entries) => {\\n  // If sentinel is visible AND we have more data AND not currently loading\\n  if (entries[0].isIntersecting && hasMore && !loading) {\\n    setPage(prev => prev + 1);\\n  }\\n});\\n\\nobserver.observe(sentinelRef.current);`}</pre>\\n                    </div>\\n                </>\\n            ) : (\\n                <pre style={{ padding: 20, background: 'var(--bg-secondary)', borderRadius: 8, overflow: 'auto', fontSize: 14 }}>\\n                    <code>{sourceCode}</code>\\n                </pre>\\n            )}\\n        </div>\\n    )\\n}\\n\\nfunction getTabStyle(isActive: boolean): React.CSSProperties {\\n    return {\\n        padding: '10px 20px',\\n        background: 'transparent',\\n        border: 'none',\\n        borderBottom: isActive ? '2px solid var(--color-primary-500)' : '2px solid transparent',\\n        cursor: 'pointer',\\n        fontWeight: isActive ? 'bold' : 'normal',\\n        color: 'var(--text-primary)'\\n    }\\n}\\n\"","import React, { useState, useEffect, useRef } from 'react'\n// @ts-ignore\nimport sourceCode from './InfiniteScroll.tsx?raw'\n\n// --- Mock API ---\nconst PAGE_SIZE = 20\nconst TOTAL_ITEMS = 100 // Limit to demonstrate \"End of list\" state\n\nfunction fetchItems(page: number): Promise<string[]> {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            const start = (page - 1) * PAGE_SIZE\n            // Generate mock items\n            const newItems = Array.from({ length: PAGE_SIZE }, (_, i) => {\n                const index = start + i + 1\n                return `Item #${index}: ${Math.random().toString(36).substring(7)}`\n            })\n\n            // Simulate end of data\n            if (start >= TOTAL_ITEMS) {\n                resolve([])\n            } else {\n                resolve(newItems)\n            }\n        }, 1000) // 1s delay\n    })\n}\n\n// --- Component ---\n\nexport default function InfiniteScroll() {\n    const [items, setItems] = useState<string[]>([])\n    const [page, setPage] = useState(1)\n    const [loading, setLoading] = useState(false)\n    const [hasMore, setHasMore] = useState(true)\n    const [activeTab, setActiveTab] = useState<'demo' | 'code'>('demo')\n\n    // The \"Sentinel\" ref - the element we observe\n    const observerTarget = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        const observer = new IntersectionObserver(\n            (entries) => {\n                if (entries[0].isIntersecting && hasMore && !loading) {\n                    setPage(prev => prev + 1)\n                }\n            },\n            { threshold: 1.0 }\n        )\n\n        if (observerTarget.current) {\n            observer.observe(observerTarget.current)\n        }\n\n        return () => observer.disconnect()\n    }, [hasMore, loading])\n\n    // Fetch data when page changes\n    useEffect(() => {\n        setLoading(true)\n        fetchItems(page).then(newItems => {\n            if (newItems.length === 0) {\n                setHasMore(false)\n            } else {\n                setItems(prev => [...prev, ...newItems])\n            }\n            setLoading(false)\n        })\n    }, [page])\n\n    return (\n        <div>\n            <h1>Infinite Scroll</h1>\n            <p>\n                Loads more data automatically when you scroll to the bottom using\n                <code>IntersectionObserver</code>.\n            </p>\n\n            <div style={{ marginBottom: 20, borderBottom: '1px solid var(--border-color)' }}>\n                <button onClick={() => setActiveTab('demo')} style={getTabStyle(activeTab === 'demo')}>Implementation</button>\n                <button onClick={() => setActiveTab('code')} style={getTabStyle(activeTab === 'code')}>Source Code</button>\n            </div>\n\n            {activeTab === 'demo' ? (\n                <>\n                    <div style={{\n                        height: 400,\n                        overflowY: 'auto',\n                        border: '1px solid var(--border-color)',\n                        borderRadius: 8,\n                        background: 'var(--bg-secondary)',\n                        position: 'relative'\n                    }}>\n                        {items.map((item, index) => (\n                            <div\n                                key={index}\n                                style={{\n                                    padding: '20px',\n                                    borderBottom: '1px solid var(--border-color)',\n                                    background: 'var(--bg-primary)'\n                                }}\n                            >\n                                {item}\n                            </div>\n                        ))}\n\n                        {/* Sentinel Element */}\n                        <div ref={observerTarget} style={{ height: 20, margin: 10, textAlign: 'center', color: '#888' }}>\n                            {loading && <span>Loading more...</span>}\n                            {!hasMore && <span>You have reached the end!</span>}\n                        </div>\n                    </div>\n\n                    <div style={{ marginTop: 40, padding: 20, background: 'var(--bg-tertiary)', borderRadius: 8 }}>\n                        <h3>Under the Hood: IntersectionObserver</h3>\n                        <p>\n                            We place a hidden (or visible loading) element at the bottom of the list.\n                            When the browser detects it's visible, we increment the page number.\n                        </p>\n                        <pre style={{ margin: 0 }}>{`const observer = new IntersectionObserver((entries) => {\n  // If sentinel is visible AND we have more data AND not currently loading\n  if (entries[0].isIntersecting && hasMore && !loading) {\n    setPage(prev => prev + 1);\n  }\n});\n\nobserver.observe(sentinelRef.current);`}</pre>\n                    </div>\n                </>\n            ) : (\n                <pre style={{ padding: 20, background: 'var(--bg-secondary)', borderRadius: 8, overflow: 'auto', fontSize: 14 }}>\n                    <code>{sourceCode}</code>\n                </pre>\n            )}\n        </div>\n    )\n}\n\nfunction getTabStyle(isActive: boolean): React.CSSProperties {\n    return {\n        padding: '10px 20px',\n        background: 'transparent',\n        border: 'none',\n        borderBottom: isActive ? '2px solid var(--color-primary-500)' : '2px solid transparent',\n        cursor: 'pointer',\n        fontWeight: isActive ? 'bold' : 'normal',\n        color: 'var(--text-primary)'\n    }\n}\n"],"names":["sourceCode","PAGE_SIZE","TOTAL_ITEMS","fetchItems","page","resolve","start","newItems","_","i","InfiniteScroll","items","setItems","useState","setPage","loading","setLoading","hasMore","setHasMore","activeTab","setActiveTab","observerTarget","useRef","useEffect","observer","entries","prev","jsx","jsxs","getTabStyle","Fragment","item","index","isActive"],"mappings":"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"}